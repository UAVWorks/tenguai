// ********************************************************************************************************************
// *                                                                                                                  *
// *    The "kernel" of abstract agent. Class has been introduced to automatically work of properties (sprouts).      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *  "Ядро" абстрактного агента. Класс был введен для автоматической работы "свойств" (они же "отростки" - Sprout).  *
// *                                                                                                                  *
// * Eugene G. Sysoletin <e.g.sysoletin@gmail.com>                                       Created 27 may 2017 at 08:31 *
// ********************************************************************************************************************

#include "AbstractAgent.h"

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                                 The constructor.                                                 *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                                    Конструктор.                                                  *
// *                                                                                                                  *
// ********************************************************************************************************************

tengu::AbstractAgent::AbstractAgent()
    : QObject()
    , AbstractEntity()
{
        
    _parent = nullptr;
    _activity = false;
        
    _parent_uuid = QString("");
    // _subProcessPath = QString("");
    
    _pub_redis = nullptr;
    _sub_redis = nullptr;
    
    __pub_redis_connected = false;
    __sub_redis_connected = false;
    
    _previousByFocus = QMap < QString, AbstractAgent * > ();
    _nextByFocus = QMap < QString, AbstractAgent * > ();
    
    _children = QMap< QString, AbstractAgent * > ();
    
    // Creating redis'es objects.
    // Создание редисовых объектов.
    
    _createRedises();
    
    // Binding redis object
    // Связка публикатора редиса.
        
    QObject::connect( _pub_redis, SIGNAL( signalConnected() ), this, SLOT( __on_pub_redis_connected() ) );
    QObject::connect( _pub_redis, SIGNAL( signalDisconnected() ), this, SLOT( __on_pub_redis_disconnected() ) );
    QObject::connect( _pub_redis, SIGNAL( signalError(QString) ), this, SLOT( __on_redis_error( QString ) ) );
    
    // Binding the subscriber redis object
    // Связка объекта подписчика на редиса.
    
    QObject::connect( _sub_redis, SIGNAL( signalConnected() ), this, SLOT( __on_sub_redis_connected() ) );
    QObject::connect( _sub_redis, SIGNAL( signalDisconnected() ), this, SLOT( __on_sub_redis_disconnected() ) );
    QObject::connect( _sub_redis, SIGNAL( signalError(QString) ), this, SLOT( __on_redis_error( QString) ) );    
  
    // The timers for agent.
    // Таймеры для этого агента.
    
    __ping_timer = new QTimer( this );
    QObject::connect( __ping_timer, SIGNAL( timeout() ), this, SLOT( __on_ping_timer() ) );
    __ping_timer->start( 100 );
    
    __connect_timer = new QTimer();
              
    QObject::connect( __connect_timer, SIGNAL( timeout() ), this, SLOT( __on_connect_timer() ) );
    __connect_timer->start( 1000 );        
    
    __must_be_connected = false;    
    __focused = false;
            
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                Abstract agent does not have himself QML Engine                                   *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                          Абстрактный агент не имеет своей собственной QML Engine.                                *
// *                                                                                                                  *
// ********************************************************************************************************************

QQmlEngine * tengu::AbstractAgent::qmlEngine() {
    
    // Finding parent for construct QML Engine. The parent must be a Process object.
    // Поиск родителя для конструирования QML Engine. Родитель должен быть объектом класса Process.
    
    AbstractAgent * parent = this->parent();
    
    while ( ( parent ) && ( parent->entityType() != AbstractEntity::ET_Process ) ) {
        parent = parent->parent();
    };
    
    if ( ( ! parent ) && ( parent->entityType() != AbstractEntity::ET_Process ) ) {
        
        // The parent was not found.
        // Родитель не был найден.
        
        emit signalFailed( tr("The process parent for QML Engine was not found. Agent name is \"") + getHumanName() + "\"" );
        return nullptr;
    };
    
    return parent->qmlEngine();
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                                  Launch this agent.                                              *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                             Запустить агента на выполнение.                                      *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::start() {
    
    // Abstract agent is not executable. The method is empty.
    // Абстрактный агент не является выполняемым. Метод - пустой.
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          Stop execution of this agent.                                           *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                      Остановка выполнения данного агента.                                        *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::stop() {
    
    if ( _activity ) {
        _activity = false;
        emit signalActivated( false );
    };
    
    if ( __focused ) {
        __focused = false;
        emit signalFocused( false );
    };
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                     Creating of redises objects. Override this procedure to change LoRedis class.                *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                   Создание объектов редиса. Перекройте эту функцию для изменения класса LoRedis.                 *
// *                                                                                                                  *
// ********************************************************************************************************************


void tengu::AbstractAgent::_createRedises() {
    
    _pub_redis = new LoRedis();
    _sub_redis = new LoRedis();
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                             Get focus of this agent.                                             *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                          Получить фокус данного агента.                                          *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::isFocused() {
    return __focused;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                             Set focus of this agent.                                             *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Установить фокус данного агента.                                         *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::setFocus ( bool focus, AbstractAgent * sender ) {
    
    Q_UNUSED( sender );
    
    if ( __focused != focus ) {
        __focused = focus;
        emit signalFocused( focus );
        if ( focus ) _tryActivate();
    };
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                         Prepare this agent for the execution.                                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                Предварительная подготовка для выполнения данного агента.                         *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::_prepare_for_execution() {
    
    // Only for direct descendants. If there are attachments, the child itself should take care of this.
    // Только для прямых потомков. Если есть вложения, то дитё должен сам об этом позаботиться.
    
    foreach ( AbstractAgent * c, _children ) {
        c->_prepare_for_execution();
    };
    
};

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                  Free resources of this agent after his execution                                *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                 Освободить ресурсы этого агента после его выполнения.                            *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::_free_after_execution() {
    
    foreach( AbstractAgent * c, _children ) {
        c->_free_after_execution();
    };    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                            Try to activate this agent.                                           *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Попытка активации данного агента.                                        *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::_tryActivate() {
    
    if ( __focused ) {
        
        // Activation of this agent.
        // Активация данного агента.
        
        __focused = false;
        emit signalFocused( false );
        _activity = true;
        emit signalActivated( _activity );
        
        // After activation we need to do at least one execution step.
        // После активации нам надо сделать как минимум один шаг выполнения.
        
        _step();
        
        return true;
    };
    
    return false;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                               Is this agent active?                                              *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                             Активен ли данный агент?                                             *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::isActive() {
    return _activity;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          One step of agent's execution.                                          *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                            Один шаг выполнения агента.                                           *
// * *
// ********************************************************************************************************************

void tengu::AbstractAgent::_step() {
    
    // By default agent does not execute.
    // По умолчанию агент не выполняется.
    
    if ( _activity ) {
        
        _activity = false;
        emit signalActivated( false );
        
        // Default behavior is transver focus for all next by focus agents.
        // Поведение по умолчанию - это передача фокуса всем следующим по фокусу агентам.
        
        bool haveOne = false;
        foreach ( AbstractAgent * next, _nextByFocus ) {
            if ( ( ! next->isFocused() ) && ( ! next->isActive() ) ) {
                next->setFocus( true, this );
                haveOne = true;
            };
        };
        
        if ( ! haveOne ) {
            qDebug() << "-->AbstractAgent::step(), " << getHumanName() << ", emit without focus";
            emit signalFailed( getHumanName() + tr(" does not have next by focus element.") );
        } else {
            emit signalFinished();        
        };
    };
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                        Return list of next focused agents.                                       *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                    Вернуть список следующих по фокусу агентов.                                   *
// *                                                                                                                  *
// ********************************************************************************************************************

QList< tengu::AbstractAgent* > tengu::AbstractAgent::nextByFocus() {
    
    QList< tengu::AbstractAgent * > result;
    foreach ( AbstractAgent * a, _nextByFocus ) {
        result.append( a );
    };
    return result;
    
};

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      Return list of previous by focus agents.                                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                    Вернуть список предыдущих по фокусу агентов.                                  *
// *                                                                                                                  *
// ********************************************************************************************************************

QList< tengu::AbstractAgent* > tengu::AbstractAgent::previousByFocus() {
    
    QList< tengu::AbstractAgent * > result;
    foreach ( AbstractAgent * a, _previousByFocus ) {
        result.append( a );
    };
    return result;
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                    Callback procedure after got some value from redis.                           *
// *                         It is empty in this class and should be overriden in the descendants.                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                           Callback-процедура после получения некоторого значения из редиса.                      *
// *                           Она в данном классе пустая, ее надо бы перекрывать в потомках.                         *
// *                                                                                                                  *
// ********************************************************************************************************************

/*
void tengu::AbstractAgent::_got_value( QString sproutName ) {
}
*/

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                              Connection timer fired.                                             *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Срабатывание таймера соединения.                                         *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_connect_timer() {

    if ( ! __must_be_connected ) return;
    
    if ( ( ! __pub_redis_connected ) && ( _pub_redis ) ) {
        _pub_redis->connect();
    };
    
    if ( ( ! __sub_redis_connected ) && ( _sub_redis ) ) {
        _sub_redis->connect();
    };
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      Ping path, show last activity of this agent.                                *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                               Путь для пинга, демонстрации последней активности агента.                          *
// *                                                                                                                  *
// ********************************************************************************************************************

QString tengu::AbstractAgent::_ping_path() {
    
    // If we have an UUID - we will identify using it. 
    // Если есть UUID - идентификация идет по нему. 
                       
    // QString channel = QString("agents.") + getUUID() + ".last_activity";
    // return channel;    
    
    return "";
        
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          On the ping timer fire event.                                           *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                               Тычок таймера пинга.                                               *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_ping_timer() {
        
    if ( ( __pub_redis_connected ) && ( ! getUUID().isEmpty() ) ) {
        
        // Publish the last live time of this agent.
        // This time allows you to conclude whether the agent is running or not
        
        // Публикация последнего времени жизни этого агента.
        // Это время позволяет делать вывод, выполняется этот агент или нет.
        
        QDateTime dt = QDateTime::currentDateTime();
        QTime time = QTime::currentTime();
        
        // Time representation with ms.
        // Представление времени с милисекундами.
        
        QString repr = QString::number( dt.toTime_t() ) + "." + QString::number( time.msec() );
        
        QString channel = _ping_path();
        
        if ( ! channel.isEmpty() ) {
            
            // It was commented. I use yet only setting value into redis, but not pub/sub.
            // Было закомментировано. Использую только значение в редисе, но не pub/sub.
            // _pub_redis->publish( channel, repr );
        
            _pub_redis->set( channel, repr );
        };
        
    };
        
    // In any case, it does not matter whether we are connected or not.
    // This is enought to call only one static class method independed of 
    // quantity of real objects.
    
    // В любом случае, не имеет значения, соединены мы или нет.
    // Достаточно просто одного вызова статической функции класса, не надо по 
    // каждому из объектов.
            
    LoRedis::processEvents();
        
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      The publisher was connected to redis.                                       *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Публикатор соединился с редисом.                                         *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_pub_redis_connected() {
    __pub_redis_connected = true;
    qDebug() << "on pub redis connected";
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      The subscriber was connected to redis.                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Подписчик соединился с редисом.                                          *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_sub_redis_connected() {
    __sub_redis_connected = true;    
    qDebug() << "on sub redis connected";
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                    The publisher was disconnected from redis.                                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                        Публикатор рассоединился с редисом.                                       *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_pub_redis_disconnected() {
    __pub_redis_connected = false;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                    The subscriber was disconnected from redis.                                   *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Подписчик рассоединился с редисом.                                       *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_sub_redis_disconnected() {
    __sub_redis_connected = false;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                         Someone from redises have an error.                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                        У кого-то из редисов возникла ошибка.                                     *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::__on_redis_error ( QString message ) {
    qDebug() << "AbstractAgent::__on_error: " << message;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                     Something has been changed in this agent.                                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                         Что-то в данном агенте изменилось.                                       *
// *                                                                                                                  *
// ********************************************************************************************************************


void tengu::AbstractAgent::_somethingChanged() {
    
    AbstractEntity::_somethingChanged();
    
    if ( ! _silent ) {
        emit signalSomethingChanged();        
    };
    
    if ( _parent ) _parent->_somethingChanged();
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                        Is the publisher connected to redis?                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                          Соединен ли публикатор с редисом?                                       *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::isPublisherConnected() {
    return __pub_redis_connected;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                       Is the subscriber connected to redis?                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                          Соединен ли подписчик с редисом?                                        *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::isSubscriberConnected() {
    return __sub_redis_connected;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      Abstract agent cannot be used directly.                                     *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                              Абстрактный агент не может быть использован напрямую.                               *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::usable() {
    return false;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                      Public connect procedure. It should be called after full initialization.                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                   Публичная процедура соединения. Ее надо вызывать после полной инициализации.                   *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::connect() {
    
    qDebug() << "AbstractAgent::connect()";
    
    __must_be_connected = true;
    
    // Connect redises if they exists.
    // Соединение редисеров, если они есть.
    
    if ( _pub_redis ) _pub_redis->connect();
    if ( _sub_redis ) _sub_redis->connect();
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                               Disconnect from RedisIO.                                           *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                                Рассоединение с редисом.                                          *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::disconnect() {
    qDebug() << "Abstract agent kernel :: disconnect()";
    __must_be_connected = false;
    if ( _pub_redis ) _pub_redis->disconnect();
    if ( _sub_redis ) _sub_redis->disconnect();
}


// ********************************************************************************************************************
// *                                                                                                                  *
// *                                           Add child to tree-like structure.                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                       Добавить ребенка в древовидную структуру.                                  *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::addChild ( tengu::AbstractAgent * child ) {
    
    if ( ! _children.contains( child->getUUID() ) ) {
        
        _children[ child->getUUID() ] = child;
        child->_parent = this;
        _somethingChanged();
        
    }
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          Remove one child from this parent.                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                       Удалить одного ребенка у этого родителя.                                   *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::removeChild ( tengu::AbstractAgent * child ) {
    
    if ( child ) {
        
        if ( _children.contains( child->getUUID() ) ) {
            _children.remove( child->getUUID() );
            _somethingChanged();
        }
        child->_parent = nullptr;
            
    };
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                Path for process to provide this agent as a separate process in the operation system.             *
// * ---------------------------------------------------------------------------------------------------------------- *
// *     Путь для процесса, который предоставляет данного агента как отдельный процесс в операционной системе.        *
// *                                                                                                                  *
// ********************************************************************************************************************

/*
QString tengu::AbstractAgent::subProcessPath() {
    return _subProcessPath;
}
*/

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          Has this agent any of children?                                         *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                           Есть ли дети у данного агента?                                         *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::hasChildren() {
    return _children.count() > 0;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                               Get all his children                                               *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                              Получить всех его детей                                             *
// *                                                                                                                  *
// ********************************************************************************************************************

QList< tengu::AbstractAgent* > tengu::AbstractAgent::children() {
    
    QList< AbstractAgent * > result;
    foreach( AbstractAgent * child, _children ) {
        result.append( child );
    };
    return result;
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                          Get all his children recursivelly                                       *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                            Получить его детей рекурсивно.                                        *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::childrenRecursive( QList< tengu::AbstractAgent * > & chlist ) {
    
    QList<AbstractAgent *> his_children = children();
    
    for ( int i=0; i<his_children.count(); i++ ) {
        AbstractAgent * och = his_children.at(i);
        och->childrenRecursive( chlist );
        chlist.append( och );
    };
    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                       Recursive delete children for this agent.                                  *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                       Рекурсивное удаление детей этого агента.                                   *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::deleteChildren() {
    
    foreach( AbstractAgent * child, _children ) {
        removeChild( child );
        delete( child );
    };
    
    _children.clear();    
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                      Adding previous (in the sence of focus transition flow) agent.                              *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                  Добавление предыдущего (в смысле течения потока передачи фокуса) агента.                        *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::addPreviousByFocus ( tengu::AbstractAgent * previous ) {
    _previousByFocus[ previous->getUUID() ] = previous;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                  Remove previous (in sence of focus) agent.                                      *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                           Удаление соседа по фокусу.                                             *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::removeNeighborByFocus ( tengu::AbstractAgent * agent ) {
    if ( agent ) {
        // removeNeighborByFocus( agent->getUUID() );    
        if ( _previousByFocus.contains( agent->getUUID() ) ) _previousByFocus.remove( agent->getUUID() );
        if ( _nextByFocus.contains( agent->getUUID() ) ) _nextByFocus.remove( agent->getUUID() );
    };
}

//void tengu::AbstractAgent::removeNeighborByFocus( QString uuid ) {
//    if ( _previousByFocus.contains( uuid ) ) _previousByFocus.remove( uuid );
//    if ( _nextByFocus.contains( uuid ) ) _nextByFocus.remove( uuid );
//};

// ********************************************************************************************************************
// *                                                                                                                  *
// *                              Adding next (in the sence of focus flow) agent.                                     *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                       Добавление следующего (в смысле потока передачи фокуса) агента.                            *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::addNextByFocus ( tengu::AbstractAgent * next ) {
    _nextByFocus[ next->getUUID() ] = next;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                      toJSON: reenterable call for his children.                                  *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                      toJSON: реентерабельный вызов для его детей.                                *
// *                                                                                                                  *
// ********************************************************************************************************************

QJsonObject tengu::AbstractAgent::toJSON() {
    
    QJsonObject obj = AbstractEntity::toJSON();
    
    if ( hasChildren() ) {
        
        QJsonArray array_of_children;
        QList< AbstractAgent * > hisChildren = children();
        for ( int i=0; i< hisChildren.count(); i++ ) {
            AbstractAgent * oneChild = hisChildren.at(i);
            array_of_children.append( oneChild->toJSON() );
        };
        obj["children"] = array_of_children;
        
    };
    
    if ( ! _previousByFocus.isEmpty() ) {
        
        QJsonArray previous_array;
        
        foreach ( AbstractAgent * prev, _previousByFocus ) {            
            previous_array.append( prev->getUUID() );
        };
        
        obj[ "previousByFocus" ] = previous_array;
    };
    
    if ( ! _nextByFocus.isEmpty() ) {
        
        QJsonArray next_array;
        
        foreach ( AbstractAgent * next, _nextByFocus ) {
            next_array.append( next->getUUID() );
        };
        
        obj[ "nextByFocus" ] = next_array;
     
    };
    
    return obj;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                 Convert from JSON form to data field of this object.                             *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                 Преобразование из JSONа в поля данных этого объекта.                             *
// *                                                                                                                  *
// ********************************************************************************************************************

bool tengu::AbstractAgent::fromJSON( QJsonObject json ) {
    bool result = AbstractEntity::fromJSON( json );
    
    _uninitedPrevious = QList<QString>();
    _uninitedNext = QList<QString>();
    
    if ( json.contains("previousByFocus") ) {
        QJsonArray arr = json.value("previousByFocus").toArray();
        for ( int i=0; i<arr.count(); i++ ) {
            _uninitedPrevious.append( arr.at(i).toString() );
        };
    };
    
    if ( json.contains("nextByFocus") ) {
        QJsonArray arr = json.value("nextByFocus").toArray();
        for ( int i=0; i<arr.count(); i++ ) {
            _uninitedNext.append( arr.at(i).toString() );
        };
    };
        
    return result;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                               Finding item by his uuid.                                          *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                              Поиск элемента по его UUIDу.                                        *
// *                                                                                                                  *
// ********************************************************************************************************************

tengu::AbstractAgent * tengu::AbstractAgent::findChildByUUID ( QString uuid ) {
    
    QList<AbstractAgent * > all;
    childrenRecursive( all );
    
    for ( int i=0; i<all.count(); i++ ) {
        
        AbstractAgent * oci = all.at(i);
        if ( oci->getUUID() == uuid ) {
            return oci;
        };
        
    };
    
    return nullptr;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                         Mark this object as non-modified.                                        *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                   Пометить данный объект как не-модифицированный.                                *
// *                                                                                                                  *
// ********************************************************************************************************************

void tengu::AbstractAgent::unmodify() {

    AbstractEntity::unmodify();
    
    foreach ( AbstractAgent * child, _children ) {
        child->unmodify();
    };
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                  Get tree-like structure parent of this agent                                    *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                       Получить для данного агента его родителя в древовидной структуре.                          *
// *                                                                                                                  *
// ********************************************************************************************************************

tengu::AbstractAgent * tengu::AbstractAgent::parent() {
    return _parent;
}

// ********************************************************************************************************************
// *                                                                                                                  *
// *                                                  The destructor.                                                 *
// * ---------------------------------------------------------------------------------------------------------------- *
// *                                                     Деструктор.                                                  *
// *                                                                                                                  *
// ********************************************************************************************************************

tengu::AbstractAgent::~AbstractAgent() {
        
    // The children are stored right here. We must clean them.
    // Дети хранятся прямо здесь и их нужно чистить.
    
    if ( _parent ) {
        _parent->removeChild( this );
    };
    
    if ( _children.size() > 0 ) {
        
        foreach ( AbstractAgent * child, _children ) {
            removeChild( child );
            delete( child );
        };
        
        _children.clear();
        
    };
    
}

